---
title: 2018年度总结-iOS路由(Khala)设计
date: 2018-12-10
categories: [iOS]
tags: [iOS,架构]
---



## 前言

关于路由选型***casa***在[**在现有工程中实施基于CTMediator的组件化方案**](https://casatwy.com/modulization_in_action.html)中已经详细的阐明其*target-action*形式的优势与具体原理使用.推荐提前阅读.

[**CTMediator**](https://github.com/casatwy/CTMediator)是一套优秀的路由组件,但由于一些业务需求与理念的微小差异,笔者使用 *swift* 实现 *target-action* 形式的路由[**Khala**](https://github.com/linhay/Khala)(~~重构于[SPRoutable](https://github.com/linhay/Routable)~~)

<!-- more -->

##  *target-action*

**单个工程中有多个业务模块，模块之间会通信，互相调用等事件,以页面跳转为例**

- 传统的编写方式:

  ```swift
  class AModuleViewController: UIViewController { }
  
  class BModuleController: UIViewController { }
  
  class CModuleController: UIViewController {
      
  	func jumpToAModule(){
  		let vc = AModuleViewController()
  		self.navigationController?.pushViewController(vc, animated: true)
  	}
      
  	func jumpToBModule(){
  		let vc = BModuleController()
  		self.navigationController?.pushViewController(vc, animated: true)
  	}
      
  }
  ```

  其会导致单业务模块`podspec`文件直接依赖其他模块,例如:

  ```ruby
  Pod::Spec.new do |s|
  s.name		= 'CModule'
  s.version 	= '1.0.0'
  s.dependency 'AModule'
  s.dependency 'BModule'  
  end
  ```

  在业务增多的情况下, 单业务模块`podspec`文件:

  ```ruby
  Pod::Spec.new do |s|
  s.name		= 'CModule'
  s.version 	= '1.0.0'
  s.dependency 'AModule'
  s.dependency 'BModule'  
  ... 100+ ...
  s.dependency 'ZModule'  
  end
  ```

-  target-action形式:

  ```swift
  class AModuleViewController: UIViewController { }
  
  class BModuleController: UIViewController { }
  
  class CModuleController: UIViewController {
      
  	func jumpToAModule(){
          let name = "AModuleViewController"
  		let type = NSClassFromString(name) as? NSObject.Type        
  		guard let vc = type.init() as? UIViewController else { return }
  		self.navigationController?.pushViewController(vc, animated: true)
  	}
      
  	func jumpToBModule(){
          let name = "BModuleViewController"
  		let type = NSClassFromString(name) as? NSObject.Type        
  		guard let vc = type.init() as? UIViewController else { return }
  		self.navigationController?.pushViewController(vc, animated: true)
  	}
      
  }
  ```

  其原理是采用runtime来动态查询类来调用其函数.

## [**Khala**]( https://github.com/linhay/Khala) vs [**CTMediator**](https://github.com/casatwy/CTMediator)

> 我们从2017年初确定采用 [**CTMediator**](https://github.com/casatwy/CTMediator) 接入我们 *swift* 项目, 发现一些处理方式与我们不太符合,大概就是有点别扭,于是参照其原理实现了[**Khala**]( https://github.com/linhay/Khala)来提供日常的业务开发.

> 路由类: target 对象
>
> 路由函数: action 函数
>
> 本地路由函数: 只提供于 iOS 端使用的路由函数

1. #### 取消 本地路由函数 & 参数常规化

   > 本地路由一般是提供模块与模块之间传递非常规参数的能力,例如: UIImage, NSObject等对象.

   我们团队在 *1.5.0* 版本中对外提供了路由函数调用机制, 主体对象为: H5 & 服务端 & ~~ReactNative~~, 此时本地路由函数却成了我们拥抱开发的最大障碍. **律己律人,**我们砍掉了所有路由函数中的非常规参数.全部调用采用标准URL的方式. 

2. #### 取消 *CTMediator* 分类机制(Category)

   **casa采用*CTMediator*来二次封装路由函数,以下是原文:**

   > mediator这个repo维护了若干个针对mediator的category，每一个对应一个target，每个category里的方法对应了这个target下所有可能的调用场景，这样调用者在包含mediator的时候，自动获得了所有可用的target-action，无论是调用还是参数传递，都非常方便。接下来我要解释一下为什么是category而不是其他：

   - category本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用category封装是很合理的。
   - 在category的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category就提供了补救的入口。
   - category可以很轻松地做请求转发，如果不采用category，请求转发逻辑就非常难做了。
   - category统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。
   - 由于category统一了所有的调用入口，使得在跨模块调用时，对于param的hardcode在整个App中的作用域仅存在于category中，在这种场景下的hardcode就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。

   **我们的探索:**

   - **参数的验证:** 我们进行了标准化参数改造后, 其实没有在这里遇到困难, 由于一些原因,我们早期创建了[**AnyFormatProtocol**](https://github.com/linhay/AnyFormatProtocol)来应对服务器参数不规律变化.顺手拿来处理该部分业务.

   - **团队的考量:** 实际上在我们团队中,一个有函数模糊提示的类,远没有一套标准文档来的有效率,尤其是涉及到多端配合的时候,一般涉及到路由功能开发流程 **文档制定 => iOS & Android 接口实现 => H5 & 服务端 接入 **,**当然适合才是最好的.**

   - **耦合性**: 只要不涉及模块调用, 可以不依赖路由组件.

   - **以下是我们单个路由类与路由函数示例:**

     ```swift
     @objc(Router_app)
     class Router_app: NSObject,AnyFormatProtocol {
       /// 调用系统级 URL
       ///
       /// 版本支持 >= 1.7.0
       /// 示例 kl://app/open?unsafe=1&url=telprompt://10086
       ///
       /// - Parameter params:
       ///   unsafe: 强制打开, 版本支持 >= 1.8.0
       ///   url: 需打开的系统级url
       @objc func router_open(params:[String:Any]) {
         /// 1.8.0,强制打开
         if format(params["unsafe"],default: false) {
           UIApplication.shared.unsafeOpen(url: format(params["url"]))
         }else {
           ///1.7.0
           UIApplication.shared.open(url: format(params["url"]))
         }
       }
       
     }
     ```

3. #### 参数类型限定为 `URL` 与 `block`

   URL部分就不再阐述了, 增添 block 的添加主要是应对 2 方面的需求:

   1. 系统的代理函数, 例如定位, 我们无法立刻获取到坐标来返回. 需要block来处理这种延时返回类型.
   2. 异步任务.

4. #### 添加广播(通知)机制

   1. *target-action* 为一对一调用场景, 而广播则为一对多调用场景设计.

5. #### 添加rewrite配置函数

   该部分灵感来源至 *nginx* 中的 `rewrite`模块.目前本司主要作用于以下方面:

   1. **页面的动态升降级:**  *H5页面 <=> 原生页面*切换
   2. **页面/函数重定向:**  A/B测试
   3. **环境隔离:** 通过不同`scheme`隔离 服务端/Native/H5 调用权限.

6. 添加日志模块

   灵感来源至 *nginx* 中的日志模块, 该部分为新增功能, 未投入生产环境使用. 预期作用:

   1. 配合后端数据快照实现页面回放.

## 本司基于路由实现的业务架构

> 可以参考, 但合适才是最好的.

![](https://s.linhey.com/iOS-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-02.png!m1)

>  [**Khala**]( https://github.com/linhay/Khala): [~~**SPRoutable**~~](https://github.com/linhay/Routable) 的重构版本,修改了之前技术能力低下导致的一些设计缺陷.
>  以下讨论全部基于: [**Khala**]( https://github.com/linhay/Khala)

## 相关链接

[2018年度总结-iOS路由(Khala)设计](https://www.linhey.com/2018/12/10/[2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93]iOS%20%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1/)

[2018年度总结-iOS模组化](https://www.linhey.com/2018/12/11/[2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93]iOS-%E6%A8%A1%E7%BB%84%E5%8C%96/)

[2018年度总结-iOS自动化构建系统](https://www.linhey.com/2018/12/10/[2018%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93]iOS%20%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F/)

## 参考

> [苹果核 - 解耦神器 —— 统跳协议和Rewrite引擎.](http://pingguohe.net/2015/11/24/Navigator-and-Rewrite.html)
>
> [蘑菇街路由组件: MGJRouter](https://github.com/meili/MGJRouter) / [阿里开源组件化方案: BeeHive](https://github.com/alibaba/BeeHive)
>
> [casa: iOS应用架构谈 组件化方案](https://casatwy.com/iOS-Modulization.html) 
>
> [bang: iOS 组件化方案探索](https://blog.cnbang.net/tech/3080/)

